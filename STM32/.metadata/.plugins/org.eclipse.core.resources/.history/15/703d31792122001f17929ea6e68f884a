/*
 * traj.c
 *
 *  Created on: May 30, 2024
 *      Author: 23877
 */

#include "traj.h"

#include <stdint.h>

void Start_Local_Traj(CSVData traj){
	CSVData traj;

}

void Start_Global_Traj(unsigned char traj_type){

}

CSVData Read_CSV(const char *filename)
{
	CSVData csvData = { .data = NULL, .rows = 0, .cols = COLS };

	// 打开CSV文件进行读取
	FILE *file = fopen(filename, "r");
	if (file == NULL) {
		perror("Error opening file");
		return csvData;
	}

	// 读取并解析文件中的每一行
	char line[1024];
	float **data = NULL;
	int capacity = 0;
	while (fgets(line, sizeof(line), file)) {
		// 移除换行符
		line[strcspn(line, "\r\n")] = 0;

		if (csvData.rows >= capacity) {
			capacity = capacity == 0 ? 10 : capacity * 2;
			data = realloc(data, capacity * sizeof(float *));
			if (data == NULL) {
				perror("Error reallocating memory");
				fclose(file);
				csvData.data = NULL;
				return csvData;
			}
		}

		data[csvData.rows] = malloc(COLS * sizeof(float));
		if (data[csvData.rows] == NULL) {
			perror("Error allocating memory");
			for (int i = 0; i < csvData.rows; ++i) {
				free(data[i]);
			}
			free(data);
			fclose(file);
			csvData.data = NULL;
			return csvData;
		}

		parseLine(line, data[csvData.rows], COLS);
		++csvData.rows;
	}

	fclose(file);
	csvData.data = data;
	return csvData;
}

// 解析一行 CSV 数据
int parseLine(char *line, float *row, int maxCols) {
    int col = 0;
    char *token = strtok(line, ",");
    while (token != NULL && col < maxCols) {
        row[col++] = atof(token);
        token = strtok(NULL, ",");
    }
    return col;
}

// 释放 CSV 数据
void freeCSVData(CSVData csvData) {
    for (int i = 0; i < csvData.rows; ++i) {
        free(csvData.data[i]);
    }
    free(csvData.data);
}
