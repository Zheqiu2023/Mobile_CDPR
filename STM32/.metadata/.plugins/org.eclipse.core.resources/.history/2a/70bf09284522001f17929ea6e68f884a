/*
 * traj.c
 *
 *  Created on: May 30, 2024
 *      Author: 23877
 */

#include "traj.h"
#include "maxon_re35.h"
#include "board.h"

#include <stdint.h>
#include <math.h>

void Start_Local_Traj(CSVData traj, float period){
	float target_pos[traj.cols];
	int32_t cmd_pos[traj.cols], cmd_vel[traj.cols], cmd_pos_prev[traj.cols];

	const TickType_t xFrequency = pdMS_TO_TICKS(1000); // 周期1秒
	TickType_t xLastWakeTime = xTaskGetTickCount();// 初始化上次唤醒时刻

	for(size_t i=0; i<traj.rows;++i)
	{
		for(size_t j=0; j<traj.cols;++j)
		{
			target_pos[j] = traj.data[i][j];
			cmd_pos_prev[j] = cmd_pos[j];
		}
		cmd_pos[0] = Cable_Convert_Pos(target_pos[0]);
		cmd_pos[1] = Archor_Convert_Pos(target_pos[1]);
		cmd_vel[0] = (int32_t)ceil(fabs((cmd_pos[0] - cmd_pos_prev[0]) * 60 / period ));
		cmd_vel[1] = (int32_t)ceil(fabs((cmd_pos[1] - cmd_pos_prev[1]) * 60 / period ));
		RE35_Motor_SetCmd(board.cable_motor, VEL_POS, cmd_vel[0], cmd_pos[0]);
		RE35_Motor_SetCmd(board.archor_motor, VEL_POS, cmd_vel[1], cmd_pos[1]);
		RE35_Motor_Send(board.cable_motor);
		RE35_Motor_Send(board.archor_motor);
		vTaskDelayUntil(&xLastWakeTime, xFrequency);
	}
}

void Start_Global_Traj(CSVData traj, float period){
	for(size_t i=0; i<traj.rows;++i)
	{
		GO_Motor_SetCmd(board.steer_motor, GO_MODE_POS, 0, 0, traj.data[i][0]);
		A1_Motor_SetCmd(board.roll_motor, A1_MODE_W, 0, A1_Convert_Vel(traj.data[i][1]), 0);
		GO_Motor_Send(board.steer_motor);
		A1_Motor_Send(board.roll_motor);
		vTaskDelayUntil(pxPreviousWakeTime, xTimeIncrement);
	}
}

CSVData Read_CSV(const char *filename)
{
	CSVData csvData = { .data = NULL, .rows = 0, .cols = COLS };

	// 打开CSV文件进行读取
	FILE *file = fopen(filename, "r");
	if (file == NULL) {
		perror("Error opening file");
		return csvData;
	}

	// 读取并解析文件中的每一行
	char line[1024];
	float **data = NULL;
	int capacity = 0;
	while (fgets(line, sizeof(line), file)) {
		// 移除换行符
		line[strcspn(line, "\r\n")] = 0;

		if (csvData.rows >= capacity) {
			capacity = capacity == 0 ? 10 : capacity * 2;
			data = realloc(data, capacity * sizeof(float *));
			if (data == NULL) {
				perror("Error reallocating memory");
				fclose(file);
				csvData.data = NULL;
				return csvData;
			}
		}

		data[csvData.rows] = malloc(COLS * sizeof(float));
		if (data[csvData.rows] == NULL) {
			perror("Error allocating memory");
			for (int i = 0; i < csvData.rows; ++i) {
				free(data[i]);
			}
			free(data);
			fclose(file);
			csvData.data = NULL;
			return csvData;
		}

		parseLine(line, data[csvData.rows], COLS);
		++csvData.rows;
	}

	fclose(file);
	csvData.data = data;
	return csvData;
}

// 解析一行 CSV 数据
int parseLine(char *line, float *row, int maxCols) {
    int col = 0;
    char *token = strtok(line, ",");
    while (token != NULL && col < maxCols) {
        row[col++] = atof(token);
        token = strtok(NULL, ",");
    }
    return col;
}

// 释放 CSV 数据
void Free_CSVData(CSVData csvData) {
    for (int i = 0; i < csvData.rows; ++i) {
        free(csvData.data[i]);
    }
    free(csvData.data);
}
