/*
 * unitree_a1.c
 *
 *  Created on: May 21, 2024
 *      Author: 23877
 */

#include "unitree_a1.h"
#include "bsp.h"
#include "usbd_cdc_if.h"

#include <stdio.h>
#include <string.h>

#define A1_REDUCTION_RATIO 9.1f
#define WHEEL_R 0.1175  // 轮胎半径（m）

A1_Motor* A1_Motor_Create(A1_Config config) {
	A1_Motor *obj = (A1_Motor*) malloc(sizeof(A1_Motor));
	if (obj == NULL) {
		// 如果内存分配失败，返回 NULL
		return NULL;
	}
	memset(obj, 0, sizeof(A1_Motor));

	obj->config = config;

	return obj;
}

void A1_Motor_SetCmd(A1_Motor *obj, A1_Ctrl_Mode mode, float T, float W, float Pos) {
	obj->motor_cmd.id = obj->config.id;
	switch (mode) {
		case A1_MODE_STOP:
			obj->motor_cmd.mode = STOP;
			obj->motor_cmd.K_P = 0;
			obj->motor_cmd.K_W = 0;
			obj->motor_cmd.T = 0;
			obj->motor_cmd.W = 0;
			obj->motor_cmd.Pos = 0;
			break;
		case A1_MODE_T:
			obj->motor_cmd.mode = CLOSED_LOOP;
			obj->motor_cmd.K_P = 0;
			obj->motor_cmd.K_W = 0;
			obj->motor_cmd.T = T;
			obj->motor_cmd.W = 0;
			obj->motor_cmd.Pos = 0;
			break;
		case A1_MODE_W:
			obj->motor_cmd.mode = CLOSED_LOOP;
			obj->motor_cmd.K_P = 0;
			obj->motor_cmd.K_W = 20;
			obj->motor_cmd.T = 0;
			obj->motor_cmd.W = W * A1_REDUCTION_RATIO * obj->config.dir;
			obj->motor_cmd.Pos = 0;
			break;
		case A1_MODE_POS:
			obj->motor_cmd.mode = CLOSED_LOOP;
			obj->motor_cmd.K_P = 0.001;
			obj->motor_cmd.K_W = 0.001;
			obj->motor_cmd.T = 0;
			obj->motor_cmd.W = 0;
			obj->motor_cmd.Pos = obj->zero_pos + Pos * A1_REDUCTION_RATIO * obj->config.dir;
			break;
		case A1_MODE_HB:
			obj->motor_cmd.mode = CLOSED_LOOP;
			obj->motor_cmd.K_P = 0.05;
			obj->motor_cmd.K_W = 3;
			obj->motor_cmd.T = T;
			obj->motor_cmd.W = W * A1_REDUCTION_RATIO * obj->config.dir;
			obj->motor_cmd.Pos = obj->zero_pos + Pos * A1_REDUCTION_RATIO * obj->config.dir;
		default:
			break;
	}
}

void A1_Modify_Data(A1Cmd *motor_s) {
	// Header
	motor_s->motor_send_data.head.start[0] = 0xFE;
	motor_s->motor_send_data.head.start[1] = 0xEE;
	motor_s->motor_send_data.head.motorID = motor_s->id;
	motor_s->motor_send_data.head.reserved = 0;
	// Command
	motor_s->motor_send_data.Mdata.mode = motor_s->mode;
	motor_s->motor_send_data.Mdata.ModifyBit = 0xFF;
	motor_s->motor_send_data.Mdata.ReadBit = 0;
	motor_s->motor_send_data.Mdata.reserved = 0;
	motor_s->motor_send_data.Mdata.Modify.u32 = 0;
	// T
	motor_s->motor_send_data.Mdata.T = (int16_t) (motor_s->T * 256) & 0xFFFF;
	// W
	motor_s->motor_send_data.Mdata.W = (int16_t) (motor_s->W * 128) & 0xFFFF;
	// Pos
	motor_s->motor_send_data.Mdata.Pos = (int32_t) (motor_s->Pos * 2607.5945876176f);  //*16384/2π
	// K_P
	motor_s->motor_send_data.Mdata.K_P = (int16_t) (motor_s->K_P * 2048) & 0xFFFF;
	// K_W
	motor_s->motor_send_data.Mdata.K_W = (int16_t) (motor_s->K_W * 1024) & 0xFFFF;
	// LowHzMotorCmdIndex & LowHzMotorCmdIndex & Res
	motor_s->motor_send_data.Mdata.LowHzMotorCmdIndex = 0;
	motor_s->motor_send_data.Mdata.LowHzMotorCmdByte = 0;
	motor_s->motor_send_data.Mdata.Res.u32 = 0;
	// CRC Data
	motor_s->motor_send_data.CRCdata.u32 = crc32_core((uint32_t*) (&(motor_s->motor_send_data)), 7);
}

void A1_Get_Send_Data(A1Cmd *motor_s, uint8_t *buf) {
	memcpy(buf, &(motor_s->motor_send_data), sizeof(MasterComdDataV3));
}

void A1_Motor_Send(A1_Motor *obj) {
	A1_Modify_Data(&(obj->motor_cmd));

	uint8_t tx_buf[34];
	memcpy(tx_buf, &(obj->motor_cmd.motor_send_data), sizeof(tx_buf));

	RS485_Send_DMA(obj->config.rs485_ind, tx_buf, sizeof(tx_buf));
}

bool A1_Extract_Data(A1Data *motor_r, uint8_t *data) {
	memcpy(&(motor_r->motor_recv_data), data, sizeof(ServoComdDataV3));

	motor_r->id = motor_r->motor_recv_data.head.motorID;
	motor_r->mode = motor_r->motor_recv_data.Mdata.mode;
	motor_r->T = motor_r->motor_recv_data.Mdata.T / 256.0f;
	motor_r->W = motor_r->motor_recv_data.Mdata.W / 128.0f;
	motor_r->LW = motor_r->motor_recv_data.Mdata.LW;
	motor_r->Pos = motor_r->motor_recv_data.Mdata.Pos * 2 * M_PI / 16384;

	// CRC data
	motor_r->motor_recv_data.CRCdata.u32 = data[74] | ((uint32_t) data[75] << 8) | ((uint32_t) data[76] << 16)
	        | ((uint32_t) data[77] << 24);

	if (motor_r->motor_recv_data.CRCdata.u32 == crc32_core((uint32_t*) data, 18))
		return motor_r->correct = true;
	else
		return motor_r->correct = false;
}

void A1_Get_Recv_Data(A1Data *motor_r, uint8_t *buf) {
	memcpy(buf, &(motor_r->motor_recv_data), sizeof(ServoComdDataV3));
}

//char str[30];

void A1_Motor_RecvData_Process(A1_Motor *obj, uint8_t *data, uint8_t len) {
	A1_Extract_Data(&(obj->motor_data), data);

	// 将浮点数转换为字符串
//	sprintf(str, "%.2f %.2f\n", obj->motor_data.LW, obj->motor_data.Pos);
//	if (CDC_Transmit_FS((uint8_t*) str, strlen(str)) != USBD_OK) {
////		HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
//		Error_Handler();
//	}
}

float A1_Convert_Vel(float vel) {
	return vel / WHEEL_R;  //   m/s转换为rad/s
}

uint32_t crc32_core(uint32_t *ptr, uint32_t len) {
	uint32_t xbit = 0;
	uint32_t data = 0;
	uint32_t CRC32 = 0xFFFFFFFF;
	const uint32_t dwPolynomial = 0x04c11db7;
	for (uint32_t i = 0; i < len; i++) {
		xbit = 1 << 31;
		data = ptr[i];
		for (uint32_t bits = 0; bits < 32; bits++) {
			if (CRC32 & 0x80000000) {
				CRC32 <<= 1;
				CRC32 ^= dwPolynomial;
			} else
				CRC32 <<= 1;
			if (data & xbit)
				CRC32 ^= dwPolynomial;
			xbit >>= 1;
		}
	}
	return CRC32;
}
